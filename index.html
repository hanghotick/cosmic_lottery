<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Fortune</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            --primary-color: #8c07d3;
            --secondary-color: #404080;
            --background-color: #000;
            --text-color: #fff;
            --button-bg: #8c07d3;
            --button-hover-bg: #a94be7;
            --button-active-bg: #6a049c;
            --button-disabled-bg: #bbb;
            --button-text: #fff;
            --input-bg: #181828;
            --input-border: #8c07d3;
            --input-focus: #a94be7;
            --spacing: 1rem;
            --sidebar-width: 280px;
            --z-overlay: 20000;
        }

        /* Layout and container styles */
        .main-game-screen {
            background: var(--background-color);
            min-height: 100vh;
            display: flex;
            flex-direction: row;
        }
        .sidebar {
            width: var(--sidebar-width);
            background: #181828;
            color: var(--text-color);
            z-index: 1000;
            transition: left 0.3s;
            position: relative;
        }
        .sidebar.open {
            left: 0;
        }
        .sidebar-toggle-button {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            margin: var(--spacing) 0;
            cursor: pointer;
            z-index: 995; /* Above sidebar, below message box */
            transition: background-color 0.3s ease;
        }
        .sidebar-content {
            padding: var(--spacing);
        }
        .game-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--background-color);
            transition: padding-left 0.3s;
        }

        /* Button styles */
        .action-button, #startButton, #restartButton, #messageBoxOkButton, #messageBoxNewGameButton, .sidebar-toggle-button {
            background: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 0.5rem;
            padding: 0.5rem 1.2rem;
            margin: 0.5rem 0;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        .action-button:hover, #startButton:hover, #restartButton:hover, #messageBoxOkButton:hover, #messageBoxNewGameButton:hover, .sidebar-toggle-button:hover {
            background: var(--button-hover-bg);
        }
        .action-button:active, #startButton:active, #restartButton:active, #messageBoxOkButton:active, #messageBoxNewGameButton:active, .sidebar-toggle-button:active {
            background: var(--button-active-bg);
        }
        .action-button:disabled, #startButton:disabled, #restartButton:disabled {
            background: var(--button-disabled-bg);
            color: #eee;
            cursor: not-allowed;
        }

        /* Input and select field styling */
        .slider-group, .input-group, .language-selector {
            display: flex;
            flex-direction: column;
            margin-bottom: var(--spacing);
        }
        .slider-group label, .input-group label, .language-selector label {
            color: var(--text-color);
            margin-bottom: 0.3rem;
            font-size: 1rem;
        }
        .slider-group input[type="range"],
        .input-group input[type="number"],
        .language-selector select {
            background: var(--input-bg);
            color: var(--text-color);
            border: 1.5px solid var(--input-border);
            border-radius: 0.4rem;
            padding: 0.3rem 0.7rem;
            font-size: 1rem;
            outline: none;
            transition: border 0.2s;
        }
        .slider-group input[type="range"]:hover,
        .input-group input[type="number"]:hover,
        .language-selector select:hover {
            border-color: var(--input-focus);
        }
        .input-group input[type="number"]:focus,
        .language-selector select:focus {
            border-color: var(--input-focus);
        }
        .input-group input[type="number"].invalid {
            border-color: #e53e3e;
            background: #2d1a1a;
        }
        .slider-group input[type="range"]::-webkit-slider-thumb {
            background: var(--primary-color);
        }
        .slider-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* Status output */
        #statusOutput {
            color: var(--primary-color);
            font-weight: bold;
            margin: 1rem 0;
            font-size: 1.1rem;
        }

        /* Message box styling with animations */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: #22223a;
            color: var(--text-color);
            border-radius: 1rem;
            box-shadow: 0 0 30px #000a;
            padding: 2rem 2.5rem;
            z-index: var(--z-overlay);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 320px;
            text-align: center;
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .message-box.hide {
            opacity: 0;
            visibility: hidden;
            transform: translate(-50%, -50%) scale(0.9);
        }

        /* Loading overlay with fade */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: var(--z-overlay);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
        }

        #loadingOverlay.show {
            opacity: 1;
            visibility: visible;
        }

        /* Phase progress indicator */
        .phase-progress {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
        }

        .phase-progress.show {
            opacity: 1;
            visibility: visible;
        }

        .phase-progress-bar {
            height: 100%;
            background: var(--primary-color);
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--primary-color);
        }

        /* Phase label */
        .phase-label {
            position: fixed;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            color: var(--text-color);
            font-size: 1rem;
            text-align: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-in-out;
        }

        .phase-label.show {
            opacity: 1;
            visibility: visible;
        }
        /* End of CSS */

        /* Debug overlay */
        #debugOverlay {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 1rem;
            border-radius: 0.5rem;
            font-family: monospace;
            font-size: 12px;
            z-index: var(--z-overlay);
            display: none;
        }

        #debugOverlay.show {
            display: block;
        }

        #debugOverlay pre {
            margin: 0;
            white-space: pre-wrap;
        }

        /* Key indicators */
        .debug-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }

        .debug-indicator.success { background: #4ade80; }
        .debug-indicator.warning { background: #fbbf24; }
        .debug-indicator.error { background: #ef4444; }
    </style>
</head>
<body>
    <div id="mainGameScreen" class="main-game-screen">
        <div id="sidebar" class="sidebar" aria-label="Sidebar">
            <button id="sidebarToggleButton" class="sidebar-toggle-button" aria-label="Toggle sidebar">‚ò∞</button>
            <div class="sidebar-content">
                <h1 style="font-size:1.5rem; font-weight:bold; margin-bottom:1.5rem;">Stellar Fortune</h1>
                <form aria-label="Game Settings" autocomplete="off">
                    <div class="language-selector">
                        <label for="languageSelect" id="labelLanguageSelect">Language: <span style="color:#aaa;">(Choose language)</span></label>
                        <select id="languageSelect" aria-label="Language selector">
                            <option value="en">English</option>
                            <option value="hu">Magyar</option>
                        </select>
                    </div>
                    <div class="slider-group">
                        <label for="zoomSlider" id="labelZoomSlider">Initial Zoom:</label>
                        <input type="range" id="zoomSlider" min="50" max="500" step="1" value="200" aria-valuemin="50" aria-valuemax="500" aria-valuenow="200" aria-label="Initial camera zoom">
                    </div>
                    <div class="input-group">
                        <label for="maxNumberInput" id="labelMaxNumberInput">Highest Lucky Number (1-10000):</label>
                        <input type="number" id="maxNumberInput" min="1" max="10000" value="1000" aria-label="Highest lucky number">
                    </div>
                    <div class="input-group">
                        <label for="numLuckyNumbersInput" id="labelNumLuckyNumbers">Number of Lucky Numbers (1-10):</label>
                        <input type="number" id="numLuckyNumbersInput" min="1" max="10" value="6" aria-label="Number of lucky numbers">
                    </div>
                    <button type="button" id="startButton" class="action-button" aria-label="Start draw">‚ñ∂Ô∏è Start ‚ñ∂Ô∏è</button>
                    <button type="button" id="restartButton" class="action-button" aria-label="Restart simulation">üîÑ Restart Simulation üîÑ</button>
                    <div id="statusOutput" role="status" aria-live="polite"></div>
                </form>
            </div>
        </div>
        <div class="game-content">
            <canvas id="particleCanvas" aria-label="3D Particle Simulation"></canvas>
        </div>
    </div>

    <div id="messageBox" class="message-box" role="dialog" aria-modal="true" aria-labelledby="messageText">
        <p id="messageText"></p>
        <button id="messageBoxOkButton" class="action-button" aria-label="OK"></button>
        <button class="action-button" id="messageBoxNewGameButton" style="display: none;" aria-label="New Game"></button>
    </div>

    <div id="loadingOverlay" style="display:none;">
        <div style="display:flex;flex-direction:column;align-items:center;">
            <div class="spinner"></div>
            <div style="color:#fff; margin-top:1.5rem; font-size:1.2rem; text-align:center;">Loading particles...</div>
        </div>
    </div>

    <div id="debugOverlay">
        <h3 style="margin:0 0 0.5rem">Debug Info</h3>
        <pre id="debugInfo"></pre>
        <div id="debugPerformance" style="margin-top:0.5rem"></div>
    </div>

    <script type="module">
        import { PARTICLE_CONFIG, ANIMATION_CONFIG, PHYSICS_CONFIG, CAMERA_CONFIG } from './js/config.js';
        import { ParticleRenderer } from './js/ParticleRenderer.js';
        import { LanguageManager } from './js/i18n/LanguageManager.js';
        import { Debug } from './js/Debug.js';

        // Initialize debug manager
        const debug = new Debug();

        // Initialize language manager
        const i18n = new LanguageManager();

        // Progress elements
        let progressBar = null;
        let progressLabel = null;

        // Update window.showMessageBox to use animations
        window.showMessageBox = function(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.innerHTML = message;
            messageBox.classList.add('show');
            
            if (window.luckyParticleSelected) {
                messageBoxNewGameButton.style.display = 'inline-block';
                messageBoxNewGameButton.textContent = i18n.t('buttons.newGame');
            }
        };

        window.hideMessageBox = function() {
            const messageBox = document.getElementById('messageBox');
            messageBox.classList.add('hide');
            setTimeout(() => {
                messageBox.classList.remove('show', 'hide');
                messageBoxNewGameButton.style.display = 'none';
            }, 300);
        };

        // Create progress elements
        function createProgressElements() {
            // Create progress bar
            progressBar = document.createElement('div');
            progressBar.className = 'phase-progress';
            const bar = document.createElement('div');
            bar.className = 'phase-progress-bar';
            progressBar.appendChild(bar);
            document.body.appendChild(progressBar);

            // Create phase label
            progressLabel = document.createElement('div');
            progressLabel.className = 'phase-label';
            document.body.appendChild(progressLabel);
        }

        // Update progress display
        function updateProgress(phase, progress) {
            if (!progressBar || !progressLabel) return;

            const bar = progressBar.querySelector('.phase-progress-bar');
            bar.style.width = `${progress * 100}%`;
            
            progressBar.classList.add('show');
            progressLabel.classList.add('show');
            progressLabel.textContent = i18n.t(`status.${phase}`);

            // Update button states
            i18n.updateButtonStates(phase);
        }

        // Hide progress elements
        function hideProgress() {
            if (progressBar) progressBar.classList.remove('show');
            if (progressLabel) progressLabel.classList.remove('show');
        }

        // --- Constants for Magic Numbers ---
        const SIDEBAR_WIDTH = 280;
        
        // Use imported configs
        const {
            STRIDE,
            RADIUS,
            SPACING,
            MAX_COUNT,
            COLOR
        } = PARTICLE_CONFIG;

        const {
            PHASES,
            DURATIONS,
            EASING
        } = ANIMATION_CONFIG;

        const {
            BOX_SIZE,
            DAMPING,
            SPEED_FACTOR,
            GRAVITY_BASE,
            ORBITAL_BASE,
            RANDOM_MOTION,
            GRAVITY_MAX,
            ORBITAL_MAX,
            ACCELERATION
        } = PHYSICS_CONFIG;

        // State Management
        const SimulationState = Object.freeze(PHASES);
        let simulationState = SimulationState.FLOATING;

        // --- Event Listener Management ---
        let eventListeners = new Map(); // Change to Map for better organization

        function addEventListenerWithTracking(target, type, handler, options) {
            // Create wrapped handler that we can reference later
            const wrappedHandler = (event) => handler(event);
            target.addEventListener(type, wrappedHandler, options);
            
            // Store in map with compound key
            const key = `${target.id || target.constructor.name}_${type}`;
            eventListeners.set(key, {
                target,
                type,
                handler: wrappedHandler,
                options
            });
        }

        function removeAllTrackedEventListeners() {
            for (const { target, type, handler, options } of eventListeners.values()) {
                try {
                    target.removeEventListener(type, handler, options);
                } catch (e) {
                    console.warn(`Failed to remove event listener: ${type}`, e);
                }
            }
            eventListeners.clear();
        }

        // Function to remove specific listener
        function removeTrackedEventListener(target, type) {
            const key = `${target.id || target.constructor.name}_${type}`;
            const listener = eventListeners.get(key);
            if (listener) {
                const { handler, options } = listener;
                target.removeEventListener(type, handler, options);
                eventListeners.delete(key);
            }
        }

        // --- Error Handling and User Feedback ---
        function showError(message) {
            window.showMessageBox(`<span style='color:#ef4444;'>${message}</span>`);
        }

        // --- DOM Element References ---
        const mainGameScreen = document.getElementById('mainGameScreen');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggleButton = document.getElementById('sidebarToggleButton');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const messageBoxOkButton = document.getElementById('messageBoxOkButton');
        const messageBoxNewGameButton = document.getElementById('messageBoxNewGameButton');
        const maxNumberInput = document.getElementById('maxNumberInput');
        const numLuckyNumbersInput = document.getElementById('numLuckyNumbersInput'); // New input
        const statusOutput = document.getElementById('statusOutput');
        const languageSelect = document.getElementById('languageSelect');
        const zoomSlider = document.getElementById('zoomSlider');
        const loadingOverlay = document.getElementById('loadingOverlay'); // Corrected reference to the loading overlay

        // --- Translations ---
        const translations = {
            en: {
                gameTitle: "Stellar Fortune", // New game title
                labelLanguageSelect: "Language:",
                labelZoomSlider: "Initial Zoom:",
                labelMaxNumberInput: "Highest Lucky Number (1 to 10000):",
                labelNumLuckyNumbers: "Number of Lucky Numbers (1-10):", // New translation
                startButton: "‚ñ∂Ô∏è Start ‚ñ∂Ô∏è", // Changed to "Start"
                startButtonDrawing: "Drawing...",
                restartButton: "üîÑ Restart Simulation üîÑ",
                statusInitial: "Click Start to begin the Lucky Draw!", // Updated initial status
                statusSwirling: "Particles are swirling...", // Updated status
                statusClashing: "Particles clashing together...", // New status
                statusSelected: "Lucky Numbers Selected!",
                messageNoParticles: "No particles to select from!",
                messageInvalidNumberInput: "Please enter a number greater than or equal to {minParticles}.",
                messageInvalidLuckyNumberInput: "Please enter a number between {min} and {max} for lucky numbers.", // New translation
                messageLuckyNumbers: "Your Lucky Numbers:",
                messageBoxOkButton: "OK",
                messageBoxNewGameButton: "üåü New Game üåü",
            },
            hu: {
                gameTitle: "Csillagj√≥sl√°s", // New game title in Hungarian
                labelLanguageSelect: "Nyelv:",
                labelZoomSlider: "Kezdeti nagy√≠t√°s:",
                labelMaxNumberInput: "Legnagyobb szerencsesz√°m (1-10000):",
                labelNumLuckyNumbers: "Szerencsesz√°mok sz√°ma (1-10):", // New translation
                startButton: "‚ñ∂Ô∏è Start ‚ñ∂Ô∏è", // Changed to "Start"
                startButtonDrawing: "Sorsol√°s...",
                restartButton: "üîÑ Szimul√°ci√≥ √∫jraind√≠t√°sa üîÑ",
                statusInitial: "Kattintson a Start gombra a szerencsesorsol√°s megkezd√©s√©hez!", // Updated initial status
                statusSwirling: "A r√©szecsk√©k kavarognak...", // Updated status
                statusClashing: "R√©szecsk√©k √ºtk√∂znek...", // New status
                statusSelected: "Szerencsesz√°mok kiv√°lasztva!",
                messageNoParticles: "Nincsenek kiv√°laszthat√≥ r√©szecsk√©k!",
                messageInvalidNumberInput: "K√©rj√ºk, adjon meg legal√°bb {minParticles} sz√°mot.",
                messageInvalidLuckyNumberInput: "K√©rj√ºk, adjon meg egy sz√°mot {min} √©s {max} k√∂z√∂tt a szerencsesz√°mokhoz.", // New translation
                messageLuckyNumbers: "Az √ñn szerencsesz√°mai:",
                messageBoxOkButton: "OK",
                messageBoxNewGameButton: "üåü √öj J√°t√©k üåü",
            }
        };

        let currentLanguage = 'en'; // Default language

        // Function to update all UI text based on the selected language
        window.setLanguage = function(lang) {
            currentLanguage = lang;
            const t = translations[currentLanguage];

            // Update page title
            document.title = t.gameTitle;
            // Update sidebar title (assuming there's an h1 in sidebar-content)
            document.querySelector('.sidebar-content h1').textContent = t.gameTitle;

            document.getElementById('labelLanguageSelect').textContent = t.labelLanguageSelect;
            document.getElementById('labelZoomSlider').textContent = t.labelZoomSlider;
            document.getElementById('labelMaxNumberInput').textContent = t.labelMaxNumberInput;
            document.getElementById('labelNumLuckyNumbers').textContent = t.labelNumLuckyNumbers; // Update new label
            document.getElementById('startButton').textContent = window.simulationStarted ? t.startButtonDrawing : t.startButton;
            document.getElementById('restartButton').textContent = t.restartButton;
            
            // Update status based on current state
            if (isLiningUp) {
                document.getElementById('statusOutput').textContent = t.statusSelected;
            } else if (isClashing) {
                document.getElementById('statusOutput').textContent = t.statusClashing;
            } else if (isSwirling) {
                document.getElementById('statusOutput').textContent = t.statusSwirling;
            } else {
                document.getElementById('statusOutput').textContent = t.statusInitial;
            }

            document.getElementById('messageBoxOkButton').textContent = t.messageBoxOkButton;
            document.getElementById('messageBoxNewGameButton').textContent = t.messageBoxNewGameButton;
        };

        // Function to display messages in a custom message box (moved here for global access)
        window.showMessageBox = function(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.innerHTML = message;
            messageBox.style.display = 'block';
            // Show New Game button only when fortune is displayed
            if (window.luckyParticleSelected) { // Only show after a draw
                messageBoxNewGameButton.style.display = 'inline-block';
            } else {
                messageBoxNewGameButton.style.display = 'none';
            }
        };

        // Function to hide the custom message box
        window.hideMessageBox = function() {
            document.getElementById('messageBox').style.display = 'none';
            messageBoxNewGameButton.style.display = 'none'; // Always hide new game button when closing
        };

        // --- Three.js Setup ---
        let scene, camera, renderer, cubeWireframe;
        let instancedParticles; // The THREE.InstancedMesh object
        let selectedParticleMeshes = []; // To store individual meshes for selected particles
        const dummy = new THREE.Object3D(); // Helper object for instance matrix updates
        const dummyColor = new THREE.Color(); // Helper object for instance color updates

        // Global parameters - Adjusted for faster random motion and clash
        let particleSpeedFactor = 0.002;
        let boxSize = 200;
        let particleRadius = 1.0;
        let damping = 0.9995;

        // Galactic Motion Parameters - Adjusted for a more "floating" effect
        let gravitationalPull = 0.00002; // Initial gravitational pull
        let orbitalVelocityFactor = 0.0002; // Initial orbital velocity
        let galacticRandomMotion = 0.02; // Increased for faster random motion

        // Intergalactic Movement Parameters (Peculiar Velocities)
        let peculiarVelocity = new THREE.Vector3(0.000005, 0.0000025, 0.000005);
        let peculiarVelocityChangeRate = 0.00000005;

        // Cosmic Expansion Parameters
        let cosmicExpansionFactor = 0.00000005;

        // Dynamic swirl parameters
        let currentOrbitalVelocityFactor = orbitalVelocityFactor;
        let currentGravitationalPull = gravitationalPull;
        const maxOrbitalVelocityFactor = 0.0015;
        const maxGravitationalPull = 0.00004;
        const swirlIncreaseRate = 0.000002;

        // Mouse rotation variables
        window.rotationSpeed = 0.005;

        // Mouse/Touch interaction for dragging
        let isDragging = false;
        let previousClientX = 0;
        let previousClientY = 0;

        // Camera orbit variables
        let cameraRadius;
        let cameraPhi;
        let cameraTheta;

        // Lucky particle selection variables
        let numberOfSelectedParticles = 6; // Now dynamic, default to 6
        let selectedParticleIndices = new Set(); // Stores indices of selected particles in window.particles
    
        let countdownInterval;
        window.luckyParticleSelected = false; // Expose to window
        let initialZoomValue;
        window.simulationStarted = false; // Controls if animation is active (for swirl/clash)

        // New state flags for particle behavior phases
        let isFloating = true; // Particles are just floating around
        let isSwirling = false; // Particles are swirling (briefly before clash)
        let isClashing = false; // Particles are pulled to center for clash (now represents explosion/hide non-selected)
        let isLiningUp = false; // Selected particles are lining up

        // Durations for phases
        const swirlDuration = 10000; // 10 seconds for the swirl effect
        const explosionDuration = 3000; // 3 seconds for the clash/explosion effect (non-selected vanish)
        const lineUpDuration = 2000; // 2 seconds for particles to line up and camera to zoom

        let clashStartTime = 0; // Reused for explosion timing
        let lineUpStartTime = 0;
        let initialCameraZForLineUp;
        const targetCameraZ = 60; // Closer zoom for lined-up particles

        // Camera Zoom limits
        const minCameraZ = 50;
        const maxCameraZ = 500;
        const zoomSensitivity = 0.1;

        // Target positions for the selected particles to line up horizontally in the center
        // This will be dynamically generated based on numberOfSelectedParticles
        let dynamicTargetParticlePositions = [];

        // Global particle color definition
        const particleColorHue = 270; // Changed to 270 for purple
        const particleColorSaturation = 70; // Default saturation
        const particleColorLightness = 60; // Default lightness
        const initialParticleColor = new THREE.Color().setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);

        // New variable for highest particle number, linked to input
        let maxParticleNumber = parseInt(maxNumberInput.value);

        // Function to generate target positions dynamically based on count
        function generateTargetParticlePositions(count) {
            const positions = [];
            const spacing = 20; // Distance between particles
            const totalWidth = (count - 1) * spacing;
            const startX = -totalWidth / 2; // Center the line of particles

            for (let i = 0; i < count; i++) {
                positions.push(new THREE.Vector3(startX + i * spacing, 0, 0));
            }
            return positions;
        }

        // Initialize Three.js scene, camera, renderer
        function initThreeJS() {
            // Crucial check: Ensure THREE is defined before proceeding
            if (typeof THREE === 'undefined') {
                console.error("THREE.js library is not loaded. Cannot initialize Three.js scene.");
                window.showMessageBox(translations[currentLanguage].messageErrorThreeJS);
                return;
            }

            scene = new THREE.Scene();
            scene.background = null; // Remove background image

            // Camera setup
            cameraRadius = parseFloat(zoomSlider.value); // Use initial zoom value as camera radius
            cameraPhi = Math.PI / 4; // Start looking slightly from the side
            cameraTheta = Math.PI / 2; // Start at the equator (looking horizontally)

            // Set initial camera position based on spherical coordinates
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0); // Always look at the center of the cube

            // Renderer setup
            const canvasElement = document.getElementById('particleCanvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasElement });
            // Set initial size based on calculated values
            const initialWidth = Math.min(window.innerWidth * 0.8, 1536);
            const initialHeight = Math.min(window.innerHeight * 0.7, 864);
            canvasElement.style.width = `${initialWidth}px`;
            canvasElement.style.height = `${initialHeight}px`;
            renderer.setSize(initialWidth, initialHeight);

            renderer.setClearColor(0x000000, 1); // Deep black background

            // Create cube wireframe border and add directly to scene
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            cubeWireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x404080 }));
            scene.add(cubeWireframe);

            initParticles(); // Set up initial particle state

            window.addEventListener('resize', onWindowResize, false);

            // Mouse and Touch interaction event listeners
            canvasElement.addEventListener('mousedown', onPointerDown, false);
            canvasElement.addEventListener('mousemove', onPointerMove, false);
            canvasElement.addEventListener('mouseup', onPointerUp, false);
            canvasElement.addEventListener('mouseleave', onPointerUp, false); // Treat mouse leaving as mouse up

            canvasElement.addEventListener('touchstart', onPointerDown, { passive: false });
            canvasElement.addEventListener('touchmove', onPointerMove, { passive: false });
            canvasElement.addEventListener('touchend', onPointerUp, false);
            canvasElement.addEventListener('touchcancel', onPointerUp, false); // Handle touch cancellation

            // Mousewheel zoom listener
            canvasElement.addEventListener('wheel', onMouseWheel, { passive: false });

            animate();
        }

        // Unified Pointer (Mouse/Touch) event handlers
        function onPointerDown(event) {
            isDragging = true;
            if (event.touches) { // Touch event
                previousClientX = event.touches[0].clientX;
                previousClientY = event.touches[0].clientY;
            } else { // Mouse event
                previousClientX = event.clientX;
                previousClientY = event.clientY;
            }
            event.preventDefault(); // Prevent default browser drag/scroll behavior
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            let currentClientX, currentClientY;
            if (event.touches) { // Touch event
                currentClientX = event.touches[0].clientX;
                currentClientY = event.touches[0].clientY;
            } else { // Mouse event
                currentClientX = event.clientX;
                currentClientY = event.clientY;
            }

            const deltaX = currentClientX - previousClientX;
            const deltaY = currentClientY - previousClientY;

            // Update spherical coordinates for camera orbit - Fixed direction
            cameraPhi -= deltaX * 0.005; // Negative for natural left-right movement
            cameraTheta -= deltaY * 0.005; // Negative for natural up-down movement

            // Clamp polar angle to prevent camera flipping over poles
            cameraTheta = Math.max(0.01, Math.min(Math.PI - 0.01, cameraTheta));

            // Recalculate camera position based on updated spherical coordinates and fixed radius
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0); // Always look at the center of the cube

            previousClientX = currentClientX;
            previousClientY = currentClientY;
            event.preventDefault();
        }

        function onPointerUp(event) {
            isDragging = false;
        }

        // Mousewheel zoom handler
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling

            // Adjust camera position based on wheel deltaY
            // Scrolling up (deltaY negative) zooms in (decrease Z)
            // Scrolling down (deltaY positive) zooms out (increase Z)
            cameraRadius += event.deltaY * zoomSensitivity;

            // Clamp camera radius within defined limits
            cameraRadius = Math.max(minCameraZ, Math.min(maxCameraZ, cameraRadius));
            
            // Update camera position based on new radius
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.updateProjectionMatrix();
        }

        // Resource tracking for proper cleanup
        let textureCache = new Map();
        let animationFrameId = null;
        let activeTimers = new Set();

        function cleanup() {
            // Cancel animation frame
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Clear all timers
            for (const timerId of activeTimers) {
                clearTimeout(timerId);
            }
            activeTimers.clear();

            // Clean up particle renderer
            if (particleRenderer) {
                particleRenderer.dispose();
                particleRenderer = null;
            }

            // Clean up textures
            for (const [key, texture] of textureCache.entries()) {
                texture.dispose();
                if (texture.image && texture.image instanceof HTMLCanvasElement) {
                    texture.image.width = 0;
                    texture.image.height = 0;
                    texture.image = null;
                }
            }
            textureCache.clear();

            // Clean up scene
            if (cubeWireframe) {
                scene.remove(cubeWireframe);
                cubeWireframe.geometry.dispose();
                cubeWireframe.material.dispose();
                cubeWireframe = null;
            }

            // Clean up WebGL renderer
            if (renderer) {
                renderer.state.reset();
                renderer.renderLists.dispose();
            }

            // Remove all event listeners
            removeAllTrackedEventListeners();

            // Reset state
            simulationState = SimulationState.FLOATING;
            isFloating = true;
            isSwirling = false;
            isClashing = false;
            isLiningUp = false;
            window.luckyParticleSelected = false;
        }

        // Enhanced createTextTexture with caching
        function createTextTexture(text, color = 'white', fontSize = 128) {
            const key = `${text}-${color}-${fontSize}`;
            if (textureCache.has(key)) {
                return textureCache.get(key);
            }

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Inter, sans-serif`;
            context.font = font;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 20;
            canvas.height = fontSize + 20;

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            textureCache.set(key, texture);
            return texture;
        }

        // WebGL context loss handling
        function initWebGLHandlers() {
            const canvas = renderer.domElement;
            
            canvas.addEventListener('webglcontextlost', handleContextLost, false);
            canvas.addEventListener('webglcontextrestored', handleContextRestored, false);

            let savedState = null;

            function handleContextLost(event) {
                event.preventDefault();
                console.log("WebGL context lost. Stopping animation...");
                
                // Save current state
                savedState = {
                    particles: window.particles.slice(),
                    selectedIndices: Array.from(selectedParticleIndices),
                    cameraPosition: camera.position.clone(),
                    cameraRotation: camera.rotation.clone(),
                    simulationState,
                    isFloating,
                    isSwirling,
                    isClashing,
                    isLiningUp
                };
                
                cleanup();
                showError(translations[currentLanguage].messageWebGLContextLost || "Graphics context lost. Please wait...");
            }

            async function handleContextRestored() {
                console.log("WebGL context restored. Reinitializing...");
                
                // Reinitialize Three.js
                await initThreeJS();
                
                // Restore saved state if available
                if (savedState) {
                    window.particles = savedState.particles;
                    selectedParticleIndices = new Set(savedState.selectedIndices);
                    camera.position.copy(savedState.cameraPosition);
                    camera.rotation.copy(savedState.cameraRotation);
                    simulationState = savedState.simulationState;
                    isFloating = savedState.isFloating;
                    isSwirling = savedState.isSwirling;
                    isClashing = savedState.isClashing;
                    isLiningUp = savedState.isLiningUp;
                    
                    // Reinitialize particles with saved state
                    initParticles(window.particles);
                    
                    savedState = null;
                }
                
                showMessage(translations[currentLanguage].messageWebGLContextRestored || "Graphics restored successfully.");
            }
        }

        // Enhanced animation function with proper frame management
        let lastFrameTime = 0;
        const TARGET_FRAMERATE = 60;
        const FRAME_INTERVAL = 1000 / TARGET_FRAMERATE;
        
        function animate(timestamp) {
            animationFrameId = requestAnimationFrame(animate);

            // Debug information update
            debug.updateMetrics();
            debug.track('Phase', simulationState);
            debug.track('Selected Particles', selectedParticleIndices.size);
            
            try {
                // State transitions and timing management
                if (isClashing) {
                    const clashProgress = (Date.now() - clashStartTime) / DURATIONS.EXPLOSION;
                    debug.track('Clash Progress', `${Math.round(clashProgress * 100)}%`);
                    
                    if (clashProgress >= 1) {
                        simulationState = SimulationState.LINING_UP;
                        isClashing = false;
                        isLiningUp = true;
                        lineUpStartTime = Date.now();
                        dynamicTargetParticlePositions = generateTargetParticlePositions(selectedParticleIndices.size);
                    }
                } else if (isLiningUp) {
                    const lineUpProgress = (Date.now() - lineUpStartTime) / DURATIONS.LINE_UP;
                    debug.track('Line-up Progress', `${Math.round(lineUpProgress * 100)}%`);
                    
                    if (lineUpProgress >= 1 && !window.luckyParticleSelected) {
                        window.luckyParticleSelected = true;
                        showLuckyNumbers();
                    }
                }

                updateParticles();
                renderer.render(scene, camera);

            } catch (error) {
                console.error('Animation error:', error);
                debug.track('Last Error', error.message);
                cleanup();
                showError(i18n.t('messages.animationError'));
            }
        }

        // Initialize everything
        async function init() {
            try {
                // Initial cleanup
                cleanup();
                
                // Initialize debug manager
                debug.init();
                
                // Initialize language manager
                await i18n.init(languageSelect.value);
                
                // Create progress elements
                createProgressElements();
                
                // Initialize Three.js
                initThreeJS();
                initWebGLHandlers();
                onWindowResize();

                // Add event listeners
                addEventListenerWithTracking(languageSelect, 'change', async (e) => {
                    await i18n.setLanguage(e.target.value);
                    i18n.updateUIText();
                });

                // Start animation
                animate();
                
                debug.track('Initialization', 'Complete');
            } catch (error) {
                console.error('Initialization error:', error);
                debug.track('Init Error', error.message);
                showError(i18n.t('messages.initError'));
            }
        }

        // Update window.onload to use init function
        window.onload = function() {
            console.log("window.onload: Starting initialization.");
            window.setLanguage(languageSelect.value);
            numberOfSelectedParticles = parseInt(numLuckyNumbersInput.value);
            init();
            console.log("window.onload: Initialization complete.");
        };

        // Handle page unload
        window.addEventListener('unload', cleanup);

        // Enhanced particle state management
        let particleUpdateQueue = [];
        let isUpdatingParticles = false;
        let lastUpdateTime = 0;
        const UPDATE_INTERVAL = 16; // ~60fps

        async function updateParticles() {
            const now = performance.now();
            if (now - lastUpdateTime < UPDATE_INTERVAL) {
                return;
            }
            lastUpdateTime = now;

            if (!worker || isUpdatingParticles) {
                return;
            }

            try {
                isUpdatingParticles = true;

                // Prepare update parameters
                const updateParams = {
                    boxSize,
                    particleSpeedFactor,
                    damping,
                    currentGravitationalPull: isSwirling ? currentGravitationalPull : gravitationalPull,
                    currentOrbitalVelocityFactor: isSwirling ? currentOrbitalVelocityFactor : orbitalVelocityFactor,
                    galacticRandomMotion,
                    peculiarVelocity: peculiarVelocity.toArray(),
                    peculiarVelocityChangeRate,
                    cosmicExpansionFactor
                };

                // Send update to worker
                worker.postMessage({
                    command: 'update',
                    data: {
                        params: updateParams,
                        phase: simulationState,
                        time: performance.now(),
                        lineUpStartTime,
                        lineUpDuration,
                        dynamicTargetParticlePositions: dynamicTargetParticlePositions.map(p => p.toArray())
                    }
                });

                // Handle worker errors
                worker.onerror = function(error) {
                    console.error('Worker error:', error);
                    handleWorkerError();
                };

            } catch (error) {
                console.error('Particle update error:', error);
                handleWorkerError();
            } finally {
                isUpdatingParticles = false;
            }
        }

        function handleWorkerError() {
            // Clean up existing worker
            if (worker) {
                worker.terminate();
                worker = null;
            }

            // Attempt to recreate worker
            try {
                initializeWorker();
                showError(translations[currentLanguage].messageWorkerRestart || "Particle system restarted due to an error");
            } catch (error) {
                console.error('Failed to restart worker:', error);
                cleanup();
                showError(translations[currentLanguage].messageWorkerFailure || "Failed to restart particle system");
            }
        }

        function initializeWorker() {
            worker = new Worker('worker.js');
            worker.postMessage({
                command: 'init',
                data: { particleCount: window.particles.length }
            });

            // Set up worker message handling
            worker.onmessage = function(e) {
                const { command, positions, velocities, error } = e.data;
                
                if (command === 'validation_error') {
                    console.error('Worker validation error:', error);
                    return;
                }

                if (command === 'updated') {
                    updateParticleVisuals(positions, velocities);
                }
            };
        }

        // Enhanced state reset and recovery
        function resetState(fullReset = false) {
            // Animation state
            simulationState = SimulationState.FLOATING;
            isFloating = true;
            isSwirling = false;
            isClashing = false;
            isLiningUp = false;
            
            // UI state
            window.luckyParticleSelected = false;
            window.simulationStarted = false;
            
            // Timer state
            clashStartTime = 0;
            lineUpStartTime = 0;
            lastUpdateTime = 0;
            lastFrameTime = 0;

            // Motion parameters
            currentOrbitalVelocityFactor = orbitalVelocityFactor;
            currentGravitationalPull = gravitationalPull;
            
            if (fullReset) {
                // Full reset includes user inputs
                maxParticleNumber = 1000;
                numberOfSelectedParticles = 6;
                maxNumberInput.value = "1000";
                numLuckyNumbersInput.value = "6";
                zoomSlider.value = "200";
                
                // Camera reset
                cameraRadius = parseFloat(zoomSlider.value);
                cameraPhi = Math.PI / 4;
                cameraTheta = Math.PI / 2;
                
                if (camera) {
                    camera.position.set(
                        cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi),
                        cameraRadius * Math.cos(cameraTheta),
                        cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi)
                    );
                    camera.lookAt(0, 0, 0);
                }
            }

            // Clear selections
            selectedParticleIndices.clear();
            
            // Update UI
            startButton.disabled = false;
            startButton.textContent = translations[currentLanguage].startButton;
            restartButton.disabled = true;
            statusOutput.textContent = translations[currentLanguage].statusInitial;
            
            // Hide any open dialogs
            window.hideMessageBox();
            
            // Reset worker if it exists
            if (worker) {
                worker.postMessage({
                    command: 'init',
                    data: { particleCount: window.particles.length }
                });
            }
        }

        // Enhanced error handling
        function handleError(error, severity = 'warning') {
            console.error(`${severity.toUpperCase()}: ${error.message || error}`);
            
            if (severity === 'fatal') {
                cleanup();
                resetState(true);
                showError(translations[currentLanguage].messageFatalError || "A fatal error occurred. The application has been reset.");
            } else {
                resetState(false);
                showError(translations[currentLanguage].messageError || "An error occurred. The simulation has been reset.");
            }
        }

        async function initParticles() {
            // Clean up existing particles
            if (particleRenderer) {
                particleRenderer.dispose();
            }

            // Initialize particle data
            const maxNumber = parseInt(maxNumberInput.value);
            const count = Math.min(maxNumber, MAX_COUNT);
            window.particles = Array.from({ length: count }, (_, i) => ({
                number: i + 1,
                selected: false
            }));

            // Create new particle renderer
            particleRenderer = new ParticleRenderer(scene, count);
            await particleRenderer.initShaders();

            // Initialize worker with particle count
            if (worker) {
                worker.postMessage({
                    command: 'init',
                    data: { particleCount: count }
                });
            }
        }

        // Update particle visuals with new positions
        function updateParticleVisuals(positions, velocities) {
            if (!particleRenderer) return;

            // Update particle positions in the shader
            particleRenderer.updatePositions(positions);
            
            // Update selected particles
            if (selectedParticleIndices.size > 0) {
                particleRenderer.updateSelection(selectedParticleIndices);
            }

            // Update time uniform for animations
            particleRenderer.updateTime(performance.now() * 0.001);
        }
    </script>
</body>
</html>
