<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Fortune</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Apply Inter font and basic body styling */
        body {
            font-family: "Inter", sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Deep black background */
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            padding: 0; /* Remove body padding as main-game-screen handles it */
            box-sizing: border-box;
            font-size: 16px; /* Base font size for rem units */
        }

        /* Main Game Screen (now always visible from start) */
        .main-game-screen {
            display: flex;
            width: 100%;
            min-height: 100vh;
            opacity: 1; /* Always visible */
            visibility: visible; /* Always visible */
            position: relative; /* For sidebar positioning */
            justify-content: center; /* Center content horizontally */
            align-items: center;
            padding: 1rem; /* Add padding here instead of body */
            box-sizing: border-box;
        }

        /* Sidebar Styles */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            width: 280px; /* Adjust width as needed */
            background-color: #1a1a2e; /* Dark background */
            color: white;
            transform: translateX(-100%); /* Hidden by default */
            transition: transform 0.3s ease-in-out;
            z-index: 990; /* Below message box, above game content */
            padding: 1rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
        }

        .sidebar.open {
            transform: translateX(0);
        }

        .sidebar-toggle-button {
            position: fixed;
            top: 1rem;
            left: 1rem;
            background-color: #6a05ad;
            color: white;
            border: none;
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            font-size: 1.5rem;
            cursor: pointer;
            z-index: 995; /* Above sidebar, below message box */
            transition: background-color 0.3s ease;
        }

        .sidebar-toggle-button:hover {
            background-color: #8c07d3;
        }

        .sidebar-content {
            width: 100%;
            padding-top: 3rem; /* Space for toggle button */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-content {
            flex-grow: 1; /* Takes up remaining space */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align canvas to top within its area */
            padding-left: 0; /* No padding initially, will adjust if sidebar is open */
            transition: padding-left 0.3s ease-in-out;
            height: 100vh; /* Ensure it takes full height */
            overflow-y: auto; /* Allow scrolling if content overflows */
        }

        .sidebar.open + .game-content {
            padding-left: 280px; /* Shift content when sidebar is open */
        }

        canvas {
            display: block;
            background-color: #000000; /* Match body background from image */
            border-radius: 1rem; /* Rounded corners for the canvas */
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5); /* Subtle shadow */
            width: 80vw; /* Responsive width */
            height: 70vh; /* Responsive height */
            max-width: 1536px; /* Max width for FHD (1920 * 0.8) */
            max-height: 864px; /* Max height for FHD (1080 * 0.8) - adjust for aspect ratio */
            margin-bottom: 1rem; /* Space between canvas and controls */
            cursor: grab; /* Indicate draggable element */
            margin-top: 1rem; /* Add some space from the top */
        }

        canvas:active {
            cursor: grabbing; /* Indicate dragging in progress */
        }

        /* Controls and output area (now inside sidebar) */
        .controls-output-container {
            background-color: #1a1a2e;
            padding: 1.5rem;
            border-radius: 1rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%; /* Take full width of sidebar-content */
            max-width: 250px; /* Max width for controls within sidebar */
            margin-top: 1rem; /* Space above controls */
            margin-bottom: 1rem; /* Ensure space at the bottom when scrolling */
        }

        .action-button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem; /* Consistent padding for touch targets */
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: clamp(1rem, 1.5vw, 1.2rem); /* Responsive font size */
            transition: background-color 0.3s ease, transform 0.1s ease, opacity 0.3s ease;
            margin-bottom: 0.75rem; /* Consistent space between buttons */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); /* Unified shadow */
        }

        .action-button:hover {
            background-color: #8c07d3;
            transform: translateY(-2px);
        }

        .action-button:active {
            transform: translateY(0);
        }

        .action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none; /* Disable clicks completely */
        }

        #startButton {
            font-size: clamp(1.1rem, 1.8vw, 1.4rem); /* Larger font for start button */
            padding: 1rem 2rem;
            margin-bottom: 1.5rem;
            background-color: #00bfff; /* Brighter blue for start button */
        }

        #startButton:hover {
            background-color: #00aacc;
        }

        #statusOutput {
            background-color: #2a2a4a;
            color: #e0e0e0;
            padding: 1rem;
            border-radius: 0.75rem;
            width: 100%;
            min-height: 50px; /* Ensure it's visible even when empty */
            text-align: center;
            font-size: clamp(0.9rem, 1.2vw, 1rem); /* Responsive font size */
            line-height: 1.4;
            display: flex; /* Use flex for centering content */
            align-items: center; /* Center vertically */
            justify-content: center; /* Center horizontally */
            word-break: break-word; /* Ensure long words breaks */
            margin-top: 1rem;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); /* Subtle inner shadow */
        }

        /* Message box styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9); /* Darker overlay */
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
            font-size: clamp(1rem, 1.5vw, 1.1rem); /* Responsive font size */
            max-width: 90vw; /* Responsive width */
            max-height: 90vh; /* Responsive height */
            overflow-y: auto; /* Scroll if content is too long */
            border: 2px solid #6a05ad; /* Purple border */
        }

        .message-box button {
            background-color: #6a05ad; /* Purple button */
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: background-color 0.3s ease;
            font-size: inherit; /* Inherit font size from message box */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); /* Unified shadow */
        }

        .message-box button:hover {
            background-color: #8c07d3;
        }

        #messageBoxNewGameButton {
            background-color: #00bfff; /* Brighter blue for New Game button */
            margin-left: 1rem; /* Space between OK and New Game */
        }
        #messageBoxNewGameButton:hover {
            background-color: #00aacc;
        }

        /* Input and Select Field Styling */
        .slider-group, .input-group, .language-selector {
            width: 100%; /* Take full width of parent (sidebar-content) */
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 0.75rem; /* Consistent vertical spacing */
            color: #e0e0e0;
            font-size: 0.9rem; /* Slightly smaller font for labels */
        }

        .slider-group label, .input-group label, .language-selector label {
            margin-bottom: 0.4rem; /* Reduced space between label and input */
            text-align: center; /* Center label text */
        }

        .slider-group input[type="range"],
        .input-group input[type="number"],
        .language-selector select {
            width: 80%; /* Shorter width for inputs */
            -webkit-appearance: none;
            appearance: none;
            padding: 0.5rem 0.75rem; /* Reduced padding for a more compact look */
            background: #4a4a6a;
            border: 1px solid #4a4a6a;
            border-radius: 0.4rem; /* Slightly smaller border-radius */
            outline: none;
            opacity: 0.8;
            transition: opacity .2s, border-color .3s ease;
            color: #e0e0e0;
            font-size: 0.9rem; /* Smaller font for input text */
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .slider-group input[type="range"]:hover,
        .input-group input[type="number"]:hover,
        .language-selector select:hover {
            opacity: 1;
        }

        .input-group input[type="number"]:focus,
        .language-selector select:focus {
            border-color: #8c07d3;
        }

        .input-group input[type="number"].invalid {
            border-color: #ef4444;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Smaller thumb */
            height: 18px; /* Smaller thumb */
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 18px; /* Smaller thumb */
            height: 18px; /* Smaller thumb */
            border-radius: 50%;
            background: #8c07d3;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }

        /* --- Loading Indicator --- */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20000;
        }

        .spinner {
            border: 6px solid #eee;
            border-top: 6px solid #8c07d3;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="mainGameScreen" class="main-game-screen">
        <div id="sidebar" class="sidebar">
            <button id="sidebarToggleButton" class="sidebar-toggle-button">‚ò∞</button>
            <div class="sidebar-content">
                <h1 style="font-size: 1.8rem; color: #00bfff; margin-bottom: 1.5rem; text-shadow: 0 0 8px rgba(0, 191, 255, 0.6);">Stellar Fortune</h1>
                <div class="language-selector">
                    <label for="languageSelect" id="labelLanguageSelect"></label>
                    <select id="languageSelect" onchange="window.setLanguage(this.value)">
                        <option value="en">English</option>
                        <option value="hu">Magyar</option>
                    </select>
                </div>
                <div class="input-group">
                    <label for="maxNumberInput" id="labelMaxNumberInput"></label>
                    <input type="number" id="maxNumberInput" min="6" max="10000" value="1000">
                </div>
                <div class="input-group">
                    <label for="numLuckyNumbersInput" id="labelNumLuckyNumbers"></label>
                    <input type="number" id="numLuckyNumbersInput" min="1" max="10" value="6">
                </div>
                <div class="slider-group">
                    <label for="zoomSlider" id="labelZoomSlider"></label>
                    <input type="range" id="zoomSlider" min="100" max="500" value="160" oninput="window.updateInitialCameraZoom(this.value)">
                </div>
                <button class="action-button" id="startButton"></button>
                <button class="action-button" id="restartButton"></button>
                <div id="statusOutput" class="llm-output"></div>
            </div>
        </div>
        <div class="game-content">
            <canvas id="particleCanvas"></canvas>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOkButton"></button>
        <button class="action-button" id="messageBoxNewGameButton" style="display: none;"></button>
    </div>

    <div id="loadingOverlay" style="display:none;">
        <div style="display:flex;flex-direction:column;align-items:center;">
            <div class="spinner" style="border: 6px solid #eee; border-top: 6px solid #8c07d3; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite;"></div>
            <div style="color:#fff; margin-top:1.5rem; font-size:1.2rem; text-align:center;">Loading particles...</div>
        </div>
    </div>

    <script type="module">
        // Global declaration of window.particles to ensure it's available before module scripts
        window.particles = [];
        console.log("Global script: window.particles initialized to:", window.particles);

        // --- DOM Element References ---
        const mainGameScreen = document.getElementById('mainGameScreen');
        const sidebar = document.getElementById('sidebar');
        const sidebarToggleButton = document.getElementById('sidebarToggleButton');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const messageBoxOkButton = document.getElementById('messageBoxOkButton');
        const messageBoxNewGameButton = document.getElementById('messageBoxNewGameButton');
        const maxNumberInput = document.getElementById('maxNumberInput');
        const numLuckyNumbersInput = document.getElementById('numLuckyNumbersInput'); // New input
        const statusOutput = document.getElementById('statusOutput');
        const languageSelect = document.getElementById('languageSelect');
        const zoomSlider = document.getElementById('zoomSlider');

        // --- Translations ---
        const translations = {
            en: {
                gameTitle: "Stellar Fortune", // New game title
                labelLanguageSelect: "Language:",
                labelZoomSlider: "Initial Zoom:",
                labelMaxNumberInput: "Highest Lucky Number (1 to 10000):",
                labelNumLuckyNumbers: "Number of Lucky Numbers (1-10):", // New translation
                startButton: "‚ñ∂Ô∏è Start ‚ñ∂Ô∏è", // Changed to "Start"
                startButtonDrawing: "Drawing...",
                restartButton: "üîÑ Restart Simulation üîÑ",
                statusInitial: "Click Start to begin the Lucky Draw!", // Updated initial status
                statusSwirling: "Spheres are floating in space...", // Updated status
                statusClashing: "Particles clashing together...", // New status
                statusSelected: "Lucky Numbers Selected!",
                messageNoParticles: "No particles to select from!",
                messageInvalidNumberInput: "Please enter a number greater than or equal to {minParticles}.",
                messageInvalidLuckyNumberInput: "Please enter a number between {min} and {max} for lucky numbers.", // New translation
                messageLuckyNumbers: "Your Lucky Numbers:",
                messageBoxOkButton: "OK",
                messageBoxNewGameButton: "üåü New Game üåü",
            },
            hu: {
                gameTitle: "Csillagj√≥sl√°s", // New game title in Hungarian
                labelLanguageSelect: "Nyelv:",
                labelZoomSlider: "Kezdeti nagy√≠t√°s:",
                labelMaxNumberInput: "Legnagyobb szerencsesz√°m (1-10000):",
                labelNumLuckyNumbers: "Szerencsesz√°mok sz√°ma (1-10):", // New translation
                startButton: "‚ñ∂Ô∏è Start ‚ñ∂Ô∏è", // Changed to "Start"
                startButtonDrawing: "Sorsol√°s...",
                restartButton: "üîÑ Szimul√°ci√≥ √∫jraind√≠t√°sa üîÑ",
                statusInitial: "Kattintson a Start gombra a szerencsesorsol√°s megkezd√©s√©hez!", // Updated initial status
                statusSwirling: "A g√∂mb√∂k a t√©rben lebegnek...", // Updated status
                statusClashing: "R√©szecsk√©k √ºtk√∂znek...", // New status
                statusSelected: "Szerencsesz√°mok kiv√°lasztva!",
                messageNoParticles: "Nincsenek kiv√°laszthat√≥ r√©szecsk√©k!",
                messageInvalidNumberInput: "K√©rj√ºk, adjon meg legal√°bb {minParticles} sz√°mot.",
                messageInvalidLuckyNumberInput: "K√©rj√ºk, adjon meg egy sz√°mot {min} √©s {max} k√∂z√∂tt a szerencsesz√°mokhoz.", // New translation
                messageLuckyNumbers: "Az √ñn szerencsesz√°mai:",
                messageBoxOkButton: "OK",
                messageBoxNewGameButton: "üåü √öj J√°t√©k üåü",
            }
        };

        let currentLanguage = 'en'; // Default language

        // Function to update all UI text based on the selected language
        window.setLanguage = function(lang) {
            currentLanguage = lang;
            const t = translations[currentLanguage];

            // Update page title
            document.title = t.gameTitle;
            // Update sidebar title (assuming there's an h1 in sidebar-content)
            document.querySelector('.sidebar-content h1').textContent = t.gameTitle;

            document.getElementById('labelLanguageSelect').textContent = t.labelLanguageSelect;
            document.getElementById('labelZoomSlider').textContent = t.labelZoomSlider;
            document.getElementById('labelMaxNumberInput').textContent = t.labelMaxNumberInput;
            document.getElementById('labelNumLuckyNumbers').textContent = t.labelNumLuckyNumbers; // Update new label
            document.getElementById('startButton').textContent = window.simulationStarted ? t.startButtonDrawing : t.startButton;
            document.getElementById('restartButton').textContent = t.restartButton;
            
            // Update status based on current state
            if (isLiningUp) {
                document.getElementById('statusOutput').textContent = t.statusSelected;
            } else if (isClashing) {
                document.getElementById('statusOutput').textContent = t.statusClashing;
            } else if (isSwirling) {
                document.getElementById('statusOutput').textContent = t.statusSwirling;
            } else {
                document.getElementById('statusOutput').textContent = t.statusInitial;
            }

            document.getElementById('messageBoxOkButton').textContent = t.messageBoxOkButton;
            document.getElementById('messageBoxNewGameButton').textContent = t.messageBoxNewGameButton;
        };

        // Function to display messages in a custom message box (moved here for global access)
        window.showMessageBox = function(message) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            messageText.innerHTML = message;
            messageBox.style.display = 'block';
            // Show New Game button only when fortune is displayed
            if (window.luckyParticleSelected) { // Only show after a draw
                messageBoxNewGameButton.style.display = 'inline-block';
            } else {
                messageBoxNewGameButton.style.display = 'none';
            }
        };

        // Function to hide the custom message box
        window.hideMessageBox = function() {
            document.getElementById('messageBox').style.display = 'none';
            messageBoxNewGameButton.style.display = 'none'; // Always hide new game button when closing
        };

        // --- Three.js Setup ---
        let scene, camera, renderer, cubeWireframe;
        let initialParticleColor = new THREE.Color();

        // Global parameters - Adjusted for faster random motion and clash
        let particleSpeedFactor = 0.002;
        let boxSize = 200;
        let particleRadius = 1.0;
        let damping = 0.9995;

        // Galactic Motion Parameters - Adjusted for a more "floating" effect
        let gravitationalPull = 0.0;
        let orbitalVelocityFactor = 0.0;
        let galacticRandomMotion = 0.02; // Increased for faster random motion

        // Intergalactic Movement Parameters (Peculiar Velocities)
        let peculiarVelocity = new THREE.Vector3(0.000005, 0.0000025, 0.000005);
        let peculiarVelocityChangeRate = 0.00000005;

        // Cosmic Expansion Parameters
        let cosmicExpansionFactor = 0.00000005;

        // Dynamic swirl parameters (not used for floating, but kept for structure)
        let currentOrbitalVelocityFactor = orbitalVelocityFactor;
        let currentGravitationalPull = gravitationalPull;
        const maxOrbitalVelocityFactor = 0.0015;
        const maxGravitationalPull = 0.00004;
        const swirlIncreaseRate = 0.000002;

        // Mouse rotation variables
        window.rotationSpeed = 0.005;

        // Mouse/Touch interaction for dragging
        let isDragging = false;
        let previousClientX = 0;
        let previousClientY = 0;

        // Camera orbit variables
        let cameraRadius;
        let cameraPhi;
        let cameraTheta;

        // Lucky particle selection variables
        let numberOfSelectedParticles = 6; // Now dynamic, default to 6
        let selectedParticlesArray = [];
    
        let countdownInterval;
        window.luckyParticleSelected = false; // Expose to window
        let initialZoomValue;
        window.simulationStarted = false; // Controls if animation is active (for swirl/clash)
        let explosionActive = false; // No longer used for fading, but kept for reference if needed

        // New state flags for particle behavior phases
        let isFloating = true; // Particles are just floating around
        let isSwirling = false; // Particles are swirling (briefly before clash)
        let isClashing = false; // Particles are pulled to center for clash
        let isLiningUp = false; // Selected particles are lining up

        let clashStartTime = 0;
        const clashDuration = 3000; // 3 seconds for the clash effect

        let lineUpStartTime = 0;
        const lineUpDuration = 2000; // 2 seconds for particles to line up and camera to zoom
        let initialCameraZForLineUp;
        const targetCameraZ = 60; // Closer zoom for lined-up particles

        // Camera Zoom limits
        const minCameraZ = 50;
        const maxCameraZ = 500;
        const zoomSensitivity = 0.1;

        // Target positions for the selected particles to line up horizontally in the center
        // This will be dynamically generated based on numberOfSelectedParticles
        let dynamicTargetParticlePositions = [];

        // Global particle color definition
        const particleColorHue = 270; // Default to purple-ish
        const particleColorSaturation = 70; // Default saturation
        const particleColorLightness = 60; // Default lightness

        // New variable for highest particle number, linked to input
        let maxParticleNumber = parseInt(maxNumberInput.value);

        // Function to generate target positions dynamically based on count
        function generateTargetParticlePositions(count) {
            const positions = [];
            const spacing = 20; // Distance between particles
            const totalWidth = (count - 1) * spacing;
            const startX = -totalWidth / 2; // Center the line of particles

            for (let i = 0; i < count; i++) {
                positions.push(new THREE.Vector3(startX + i * spacing, 0, 0));
            }
            return positions;
        }

        // Initialize Three.js scene, camera, renderer
        function initThreeJS() {
            // Crucial check: Ensure THREE is defined before proceeding
            if (typeof THREE === 'undefined') {
                console.error("THREE.js library is not loaded. Cannot initialize Three.js scene.");
                window.showMessageBox(translations[currentLanguage].messageErrorThreeJS);
                return;
            }

            scene = new THREE.Scene();

            // Remove background image by setting scene.background to null
            scene.background = null; 

            // Camera setup
            cameraRadius = parseFloat(zoomSlider.value); // Use initial zoom value as camera radius
            cameraPhi = Math.PI / 4; // Start looking slightly from the side
            cameraTheta = Math.PI / 2; // Start at the equator (looking horizontally)

            // Set initial camera position based on spherical coordinates
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0); // Always look at the center of the cube

            // Renderer setup
            const canvasElement = document.getElementById('particleCanvas');
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasElement });
            // Set initial size based on calculated values
            const initialWidth = Math.min(window.innerWidth * 0.8, 1536);
            const initialHeight = Math.min(window.innerHeight * 0.7, 864);
            canvasElement.style.width = `${initialWidth}px`;
            canvasElement.style.height = `${initialHeight}px`;
            renderer.setSize(initialWidth, initialHeight);


            renderer.setClearColor(0x000000, 1); // Deep black background

            // Create cube wireframe border
            const geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(geometry);
            cubeWireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x404080 }));
            scene.add(cubeWireframe);

            initParticles(); // Set up initial particle state

            window.addEventListener('resize', onWindowResize, false);

            // Mouse and Touch interaction event listeners
            canvasElement.addEventListener('mousedown', onPointerDown, false);
            canvasElement.addEventListener('mousemove', onPointerMove, false);
            canvasElement.addEventListener('mouseup', onPointerUp, false);
            canvasElement.addEventListener('mouseleave', onPointerUp, false); // Treat mouse leaving as mouse up

            canvasElement.addEventListener('touchstart', onPointerDown, { passive: false });
            canvasElement.addEventListener('touchmove', onPointerMove, { passive: false });
            canvasElement.addEventListener('touchend', onPointerUp, false);
            canvasElement.addEventListener('touchcancel', onPointerUp, false); // Handle touch cancellation

            // Mousewheel zoom listener
            canvasElement.addEventListener('wheel', onMouseWheel, { passive: false });

            animate();
        }

        // Unified Pointer (Mouse/Touch) event handlers
        function onPointerDown(event) {
            isDragging = true;
            if (event.touches) { // Touch event
                previousClientX = event.touches[0].clientX;
                previousClientY = event.touches[0].clientY;
            } else { // Mouse event
                previousClientX = event.clientX;
                previousClientY = event.clientY;
            }
            event.preventDefault(); // Prevent default browser drag/scroll behavior
        }

        function onPointerMove(event) {
            if (!isDragging) return;

            let currentClientX, currentClientY;
            if (event.touches) { // Touch event
                currentClientX = event.touches[0].clientX;
                currentClientY = event.touches[0].clientY;
            } else { // Mouse event
                currentClientX = event.clientX;
                currentClientY = event.clientY;
            }

            const deltaX = currentClientX - previousClientX;
            const deltaY = currentClientY - previousClientY;

            // Update spherical coordinates for camera orbit
            cameraPhi += deltaX * 0.005; // Azimuthal angle
            cameraTheta += deltaY * 0.005; // Polar angle

            // Clamp polar angle to prevent camera flipping over poles
            cameraTheta = Math.max(0.01, Math.min(Math.PI - 0.01, cameraTheta));

            // Recalculate camera position based on updated spherical coordinates and fixed radius
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0); // Always look at the center of the cube

            previousClientX = currentClientX;
            previousClientY = currentClientY;
            event.preventDefault();
        }

        function onPointerUp(event) {
            isDragging = false;
        }

        // Mousewheel zoom handler
        function onMouseWheel(event) {
            event.preventDefault(); // Prevent page scrolling

            // Adjust camera position based on wheel deltaY
            // Scrolling up (deltaY negative) zooms in (decrease Z)
            // Scrolling down (deltaY positive) zooms out (increase Z)
            cameraRadius += event.deltaY * zoomSensitivity;

            // Clamp camera radius within defined limits
            cameraRadius = Math.max(minCameraZ, Math.min(maxCameraZ, cameraRadius));
            
            // Update camera position based on new radius
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);

            camera.updateProjectionMatrix();
        }

        // Function to create a CanvasTexture for text
        function createTextTexture(text, color = 'white', fontSize = 128) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const font = `${fontSize}px Inter, sans-serif`; // Use Inter font
            context.font = font;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 20; // Add padding
            canvas.height = fontSize + 20; // Add padding

            context.font = font;
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Initialize particles as THREE.Mesh spheres
        function initParticles() {
            showLoading();
            setTimeout(() => { // Allow spinner to show for at least a frame
                console.log("initParticles: Current window.particles.length before clearing:", window.particles.length); // Debugging log

                // Remove existing particles from scene and dispose geometries/materials
                window.particles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                    if (p.textMesh) {
                        if (p.mesh.children.includes(p.textMesh)) {
                            p.mesh.remove(p.textMesh);
                        }
                        p.textMesh.geometry.dispose();
                        p.textMesh.material.dispose();
                    }
                });
                window.particles = []; // Clear the array
                selectedParticlesArray = []; // Reset selected particles array
                window.luckyParticleSelected = false; // Reset flag
                
                // Reset state flags
                isFloating = true;
                isSwirling = false;
                isClashing = false;
                isLiningUp = false;

                statusOutput.textContent = translations[currentLanguage].statusInitial; // Reset status text

                // Reset dynamic swirl parameters (not used for floating, but kept for structure)
                currentOrbitalVelocityFactor = orbitalVelocityFactor;
                currentGravitationalPull = gravitationalPull;

                console.log("initParticles: maxParticleNumber is", maxParticleNumber); // Debugging log

                const center = new THREE.Vector3(0, 0, 0);
                const sphereGeometry = new THREE.SphereGeometry(particleRadius, 16, 16);

                initialParticleColor.setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);

                try { // Added try-catch for particle creation loop
                    // Create particles up to maxParticleNumber
                    for (let i = 0; i < maxParticleNumber; i++) {
                        let x = (Math.random() - 0.5) * boxSize;
                        let y = (Math.random() - 0.5) * boxSize;
                        let z = (Math.random() - 0.5) * boxSize;

                        const particlePos = new THREE.Vector3(x, y, z);
                        const material = new THREE.MeshBasicMaterial({ color: initialParticleColor.clone() });
                        const mesh = new THREE.Mesh(sphereGeometry, material);
                        mesh.position.set(x, y, z);
                        scene.add(mesh);

                        // Initialize particles with very low velocity for initial "floating"
                        const initialVelocity = new THREE.Vector3(
                            (Math.random() - 0.5) * particleSpeedFactor * 0.1,
                            (Math.random() - 0.5) * particleSpeedFactor * 0.1,
                            (Math.random() - 0.5) * particleSpeedFactor * 0.1
                        );

                        window.particles.push({ // Use window.particles
                            mesh: mesh,
                            velocity: initialVelocity,
                            number: i + 1 // Particles are numbered from 1 up to maxParticleNumber
                        });
                        // Log first and last particle to confirm pushing
                        if (i === 0 || i === maxParticleNumber - 1) {
                            console.log(`initParticles: Pushed particle ${i + 1}. Current array size: ${window.particles.length}`);
                        }
                    }
                } catch (error) {
                    console.error("Error during particle creation in initParticles:", error); // Ensure this is visible
                    window.showMessageBox("Error creating particles. Check console for details.");
                }
                console.log("initParticles: Particles created, total:", window.particles.length); // Debugging log
                // Reset camera to initial position on re-init
                camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
                camera.position.y = cameraRadius * Math.cos(cameraTheta);
                camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
                camera.lookAt(0, 0, 0);
                hideLoading();
            }, 10);
        }

        // --- Web Worker Setup for Physics ---
        let physicsWorker = null;
        let useWorker = true; // Set to false to disable worker for debugging
        let workerParticles = [];

        function startPhysicsWorker() {
            if (!useWorker) return;
            if (physicsWorker) physicsWorker.terminate();
            // Use relative path for GitHub Pages compatibility
            physicsWorker = new Worker('./worker.js');
            physicsWorker.onmessage = function(e) {
                const updated = e.data.particles;
                // Update main thread particle positions/velocities
                for (let i = 0; i < window.particles.length; i++) {
                    window.particles[i].mesh.position.set(...updated[i].position);
                    window.particles[i].velocity.set(...updated[i].velocity);
                }
            };
        }

        function updateParticlesWithWorker(phase) {
            if (!useWorker || !physicsWorker) return false;
            // Prepare data for worker
            const particlesData = window.particles.map(p => ({
                position: [p.mesh.position.x, p.mesh.position.y, p.mesh.position.z],
                velocity: [p.velocity.x, p.velocity.y, p.velocity.z]
            }));
            const params = {
                damping, galacticRandomMotion, peculiarVelocity: [peculiarVelocity.x,peculiarVelocity.y,peculiarVelocity.z],
                cosmicExpansionFactor, boxSize, particleRadius, clashInwardForce: 0.005
            };
            const selectedIndices = selectedParticlesArray.map(p => window.particles.indexOf(p));
            physicsWorker.postMessage({
                particles: particlesData,
                params,
                phase,
                selectedIndices,
                time: Date.now(),
                lineUpStartTime,
                lineUpDuration,
                dynamicTargetParticlePositions: dynamicTargetParticlePositions.map(v => [v.x, v.y, v.z])
            });
            return true;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            let phase = isFloating ? 'floating' : isSwirling ? 'swirling' : isClashing ? 'clashing' : isLiningUp ? 'liningUp' : 'floating';
            if (!updateParticlesWithWorker(phase)) {
                updateParticles(); // fallback to main thread if worker not used
            }
            renderer.render(scene, camera);
        }

        // Update particle positions and handle interactions/boundaries
        function updateParticles() {
            const center = new THREE.Vector3(0, 0, 0);

            // Slowly change the direction of peculiar velocity (always active)
            peculiarVelocity.x += (Math.random() - 0.5) * peculiarVelocityChangeRate;
            peculiarVelocity.y += (Math.random() - 0.5) * peculiarVelocityChangeRate;
            peculiarVelocity.z += (Math.random() - 0.5) * peculiarVelocityChangeRate;

            for (let i = 0; i < window.particles.length; i++) {
                const p = window.particles[i];
                const isSelected = selectedParticlesArray.includes(p);

                // Apply damping
                p.velocity.multiplyScalar(damping);

                if (isFloating || isSwirling) { // Initial floating or swirling phase
                    p.velocity.x += (Math.random() - 0.5) * galacticRandomMotion;
                    p.velocity.y += (Math.random() - 0.5) * galacticRandomMotion;
                    p.velocity.z += (Math.random() - 0.5) * galacticRandomMotion;
                    p.velocity.add(peculiarVelocity);
                    const cosmicExpansionForce = new THREE.Vector3().subVectors(p.mesh.position, center).normalize().multiplyScalar(cosmicExpansionFactor);
                    p.velocity.add(cosmicExpansionForce);

                    // Dynamic color shift during floating/swirling
                    p.mesh.material.color.setHSL(
                        (particleColorHue / 360 + Math.sin(Date.now() * 0.0001 + i * 0.01) * 0.05) % 1,
                        particleColorSaturation / 100,
                        particleColorLightness / 100
                    );

                } else if (isClashing) { // Clashing phase
                    // Strong inward pull for all particles during clash
                    const clashInwardForce = 0.005; // Define clash force here
                    const directionToCenter = new THREE.Vector3().subVectors(center, p.mesh.position).normalize();
                    p.velocity.add(directionToCenter.multiplyScalar(clashInwardForce));

                    // Dynamic color shift during clash
                    p.mesh.material.color.setHSL(
                        (particleColorHue / 360 + Math.sin(Date.now() * 0.0001 + i * 0.01) * 0.05) % 1,
                        particleColorSaturation / 100,
                        particleColorLightness / 100
                    );

                } else if (isLiningUp) { // Lining up phase
                    if (isSelected) {
                        // Selected particles interpolate to target positions
                        const elapsedTime = Date.now() - lineUpStartTime;
                        let t = Math.min(1, elapsedTime / lineUpDuration);
                        const selectedIndex = selectedParticlesArray.indexOf(p);
                        if (selectedIndex !== -1 && dynamicTargetParticlePositions[selectedIndex]) { // Use dynamic positions
                            p.mesh.position.lerp(dynamicTargetParticlePositions[selectedIndex], t);
                            p.velocity.set(0, 0, 0); // Stop other forces for selected particles during line up
                        }
                        p.mesh.material.color.setHSL(particleColorHue / 360, particleColorSaturation / 100, particleColorLightness / 100);
                    } else {
                        // Non-selected particles resume floating after clash ends
                        p.velocity.x += (Math.random() - 0.5) * galacticRandomMotion;
                        p.velocity.y += (Math.random() - 0.5) * galacticRandomMotion;
                        p.velocity.z += (Math.random() - 0.5) * galacticRandomMotion;
                        p.velocity.add(peculiarVelocity);
                        const cosmicExpansionForce = new THREE.Vector3().subVectors(p.mesh.position, center).normalize().multiplyScalar(cosmicExpansionFactor);
                        p.velocity.add(cosmicExpansionForce);
                        // Keep their dynamic color shift
                        p.mesh.material.color.setHSL(
                            (particleColorHue / 360 + Math.sin(Date.now() * 0.0001 + i * 0.01) * 0.05) % 1,
                            particleColorSaturation / 100,
                            particleColorLightness / 100
                        );
                    }
                }

                // Ensure minimum speed for continuous floating (only if not lining up for non-selected)
                const minContinuousSpeed = 0.0005;
                if (!isLiningUp && p.velocity.length() < minContinuousSpeed) {
                    p.velocity.x += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.y += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                    p.velocity.z += (Math.random() - 0.5) * particleSpeedFactor * 0.5;
                }

                p.mesh.position.add(p.velocity);

                // Boundary collision (bounce off cube walls) and clamp position
                const halfBox = boxSize / 2;
                let collided = false;

                if (p.mesh.position.x + particleRadius > halfBox) {
                    p.velocity.x *= -1;
                    p.mesh.position.x = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.x - particleRadius < -halfBox) {
                    p.velocity.x *= -1;
                    p.mesh.position.x = -halfBox + particleRadius;
                    collided = true;
                }

                if (p.mesh.position.y + particleRadius > halfBox) {
                    p.velocity.y *= -1;
                    p.mesh.position.y = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.y - particleRadius < -halfBox) {
                    p.velocity.y *= -1;
                    p.mesh.position.y = -halfBox + particleRadius;
                    collided = true;
                }

                if (p.mesh.position.z + particleRadius > halfBox) {
                    p.velocity.z *= -1;
                    p.mesh.position.z = halfBox - particleRadius;
                    collided = true;
                } else if (p.mesh.position.z - particleRadius < -halfBox) {
                    p.velocity.z *= -1;
                    p.mesh.position.z = -halfBox + particleRadius;
                    collided = true;
                }

                // Change color if collision occurred (only before selection)
                if (collided && !window.luckyParticleSelected) {
                    const newColor = new THREE.Color();
                    const newHue = Math.random();
                    const newSaturation = 0.7 + Math.random() * 0.3;
                    const newLightness = 0.5 + Math.random() * 0.3;
                    newColor.setHSL(newHue, newSaturation, newLightness);
                    p.mesh.material.color.copy(newColor);
                }
            }
            // Camera zoom animation during lining up (only if isLiningUp is true)
            if (isLiningUp) {
                const elapsedTime = Date.now() - lineUpStartTime;
                let t = Math.min(1, elapsedTime / lineUpDuration);
                camera.position.z = THREE.MathUtils.lerp(initialCameraZForLineUp, targetCameraZ, t);
                camera.lookAt(0, 0, 0); // Keep camera focused on the center
            }
        }

        function onWindowResize() {
            const canvasElement = document.getElementById('particleCanvas');
            // Recalculate size based on current window dimensions and max constraints
            const newWidth = Math.min(window.innerWidth * 0.8, 1536);
            const newHeight = Math.min(window.innerHeight * 0.7, 864);

            canvasElement.style.width = `${newWidth}px`;
            canvasElement.style.height = `${newHeight}px`;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(newWidth, newHeight);

            // Adjust game-content padding if sidebar is open
            if (sidebar.classList.contains('open')) {
                document.querySelector('.game-content').style.paddingLeft = '280px';
            } else {
                document.querySelector('.game-content').style.paddingLeft = '0';
            }
        }

        // Function to update initial camera zoom (from slider)
        window.updateInitialCameraZoom = function(value) { // Expose to window
            cameraRadius = parseFloat(value); // Update camera radius
            // Recalculate camera position immediately based on new radius and current angles
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.updateProjectionMatrix(); // Important to update projection matrix after position change
        }

        // Function to update the maximum particle number from the input
        maxNumberInput.addEventListener('change', function() {
            const newMax = parseInt(this.value);
            if (isNaN(newMax) || newMax < numberOfSelectedParticles) { // Ensure minimum of 6 particles
                this.value = maxParticleNumber; // Revert to old value if invalid
                this.classList.add('invalid'); // Add invalid class for visual feedback
                setTimeout(() => this.classList.remove('invalid'), 1500); // Remove after 1.5s
                window.showMessageBox(translations[currentLanguage].messageInvalidNumberInput.replace('{minParticles}', numberOfSelectedParticles));
                return;
            }
            maxParticleNumber = newMax;
            // Restart simulation to apply the new number range
            window.restartSimulation();
        });

        // Event listener for the new "Number of Lucky Numbers" input
        numLuckyNumbersInput.addEventListener('change', function() {
            const newNum = parseInt(this.value);
            if (isNaN(newNum) || newNum < 1 || newNum > 10) {
                this.value = numberOfSelectedParticles; // Revert to old value
                this.classList.add('invalid');
                setTimeout(() => this.classList.remove('invalid'), 1500);
                window.showMessageBox(translations[currentLanguage].messageInvalidLuckyNumberInput.replace('{min}', 1).replace('{max}', 10));
                return;
            }
            numberOfSelectedParticles = newNum;
            // No need to restart simulation here, as it will be applied on the next draw
        });


        function displayLuckyNumbersOnly(selectedNumbersString) {
            const t = translations[currentLanguage];
            const message = `
                <p style="font-weight: bold; font-size: 1.5em; margin-bottom: 1em;">${t.messageLuckyNumbers} ${selectedNumbersString}</p>
            `;
            window.showMessageBox(message);
        }


        // --- Game Flow Functions ---
        // This function is now the primary entry point for starting/restarting the game
        function newGame() {
            window.hideMessageBox(); // Hide any open message box
            window.restartSimulation(); // Reset the 3D simulation
            sidebar.classList.add('open'); // Ensure sidebar is open for new game setup
            document.querySelector('.game-content').style.paddingLeft = '280px'; // Adjust padding
            // No immediate startLuckyDraw here, as the user will click the button
        }

        // startLuckyDraw is now exposed globally via window.startLuckyDraw in the module script
        window.startLuckyDraw = function() {
            if (isSwirling || isClashing || isLiningUp) { // Already in a process
                window.restartSimulation();
                return;
            }
            isFloating = false; // Stop floating
            isSwirling = true; // Start swirling (briefly)
            statusOutput.textContent = translations[currentLanguage].statusSwirling;
            startButton.textContent = translations[currentLanguage].startButtonDrawing;
            startButton.disabled = true;

            setTimeout(() => {
                isSwirling = false; // End swirling
                isClashing = true; // Start clashing
                clashStartTime = Date.now(); // Record clash start time
                statusOutput.textContent = translations[currentLanguage].statusClashing; // Update status

                window.autoSelectLuckyParticles(); // Select particles and trigger clash behavior
            }, 5000); // Swirling duration before clash (reduced to 5 seconds for quicker action)
        };

        // Expose autoSelectLuckyParticles to the global scope
        window.autoSelectLuckyParticles = function() {
            console.log("autoSelectLuckyParticles: Current window.particles array length:", window.particles.length); // Debugging log
            if (window.particles.length === 0) { // Use window.particles
                window.showMessageBox(translations[currentLanguage].messageNoParticles);
                startButton.disabled = false; // Re-enable start button
                startButton.textContent = translations[currentLanguage].startButton; // Reset button text
                return;
            }

            selectedParticlesArray = [];
            // Create a fresh array of available indices for unbiased selection.
            // This ensures every particle has an equal chance of being picked.
            const availableIndices = Array.from({ length: window.particles.length }, (_, i) => i);

            // Dynamically generate target positions for the selected particles
            dynamicTargetParticlePositions = generateTargetParticlePositions(numberOfSelectedParticles);

            for (let i = 0; i < numberOfSelectedParticles; i++) {
                if (availableIndices.length === 0) break;

                // Randomly select an index from the available pool.
                // This provides equal probability for all remaining particles.
                const randomIndex = Math.floor(Math.random() * availableIndices.length);
                // Get the actual particle index and remove it from the available pool.
                // This ensures independence of outcomes and no duplicate selections.
                const particleIndex = availableIndices.splice(randomIndex, 1)[0];
                const p = window.particles[particleIndex]; // Use window.particles

                selectedParticlesArray.push(p);

                // Add text mesh for each selected particle
                const textTexture = createTextTexture(String(p.number), 'white', 128);
                const textMaterial = new THREE.MeshBasicMaterial({ map: textTexture, transparent: true, side: THREE.DoubleSide });
                const textScaleFactor = 0.5;
                const textGeometry = new THREE.PlaneGeometry(
                    textTexture.image.width / 100 * textScaleFactor,
                    textTexture.image.height / 100 * textScaleFactor
                );
                p.textMesh = new THREE.Mesh(textGeometry, textMaterial);
                p.textMesh.position.z = particleRadius + 0.1;
                p.mesh.add(p.textMesh);
            }

            window.luckyParticleSelected = true; // Flag indicating selection has occurred

            const selectedNumbers = selectedParticlesArray.map(p => p.number).join(', ');
            
            // Set timeout to end clashing and start lining up
            setTimeout(() => {
                isClashing = false; // End clashing
                isLiningUp = true; // Start lining up
                lineUpStartTime = Date.now(); // Record line up start time
                statusOutput.textContent = translations[currentLanguage].statusSelected; // Update status

                // The displayLuckyNumbersOnly will be called after lineUpDuration
                setTimeout(() => {
                    isLiningUp = false; // End lining up
                    displayLuckyNumbersOnly(selectedNumbers);
                    startButton.disabled = false;
                    startButton.textContent = translations[currentLanguage].startButton;
                }, lineUpDuration);
            }, clashDuration); // Clash duration
        };

        // Expose restartSimulation to the global scope
        window.restartSimulation = function() {
            clearInterval(countdownInterval); // Still good to clear any lingering interval, though not strictly needed here
            
            // Reset all state flags
            isFloating = true;
            isSwirling = false;
            isClashing = false;
            isLiningUp = false;
            window.luckyParticleSelected = false;

            startButton.disabled = false; // Re-enable start button
            startButton.textContent = translations[currentLanguage].startButton; // Reset button text

            initParticles(); // Re-initialize particles and scene

            // Reset camera position to initial state
            camera.position.x = cameraRadius * Math.sin(cameraTheta) * Math.sin(cameraPhi);
            camera.position.y = cameraRadius * Math.cos(cameraTheta);
            camera.position.z = cameraRadius * Math.sin(cameraTheta) * Math.cos(cameraPhi);
            camera.lookAt(0, 0, 0);
        };

        // Function to toggle sidebar visibility
        function toggleSidebar() {
            sidebar.classList.toggle('open');
            // Adjust game-content padding based on sidebar state
            if (sidebar.classList.contains('open')) {
                document.querySelector('.game-content').style.paddingLeft = '280px';
            } else {
                document.querySelector('.game-content').style.paddingLeft = '0';
            }
        }


        // Initialize and start animation when the window loads
        window.onload = async function() {
            console.log("window.onload: Starting initialization.");
            
            // Set initial language
            window.setLanguage(languageSelect.value);

            // Set initial value for numberOfSelectedParticles from input
            numberOfSelectedParticles = parseInt(numLuckyNumbersInput.value);

            // Initialize Three.js and particles
            initThreeJS();
            onWindowResize();

            // Attach event listeners to buttons
            startButton.addEventListener('click', window.startLuckyDraw);
            restartButton.addEventListener('click', window.restartSimulation);
            messageBoxOkButton.addEventListener('click', window.hideMessageBox);
            messageBoxNewGameButton.addEventListener('click', newGame); // New game button now calls newGame()
            sidebarToggleButton.addEventListener('click', toggleSidebar); // Attach toggle button listener

            // Open sidebar by default on load
            sidebar.classList.add('open');
            document.querySelector('.game-content').style.paddingLeft = '280px';

            // Initial state: particles are floating, not swirling intensely
            // The `updateParticles` function will handle the floating motion when `isFloating` is true.
            statusOutput.textContent = translations[currentLanguage].statusInitial;

            startPhysicsWorker();

            console.log("window.onload: Initialization complete.");
        };

    </script>
</body>
</html>
